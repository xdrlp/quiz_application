// Firestore Security Rules for Quiz Application
// Deploy to Firebase Console: Firestore > Rules

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUser(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    function getUser(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }
    
    // Safe check for class access
    function hasClassAccess(quizClassIds) {
       // Check if user doc exists
       return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
              // Check if 'classes' field exists
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.keys().hasAny(['classes']) &&
              // Check intersection
              quizClassIds.hasAny(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.classes);
    }
    
    function getQuiz(quizId) {
      return get(/databases/$(database)/documents/quizzes/$(quizId)).data;
    }
    
    function isQuizCreator(quizId) {
      return isAuthenticated() && getQuiz(quizId).createdBy == request.auth.uid;
    }
    
    function isClassMember(classId) {
      return isAuthenticated() && 
             classId in getUser(request.auth.uid).classes;
    }
    
    function isClassTeacher(classId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/classes/$(classId)).data.teacherUid == request.auth.uid;
    }

    // ========== USERS COLLECTION ==========
    match /users/{uid} {
      // Allow any authenticated user to read (needed to fetch creator profile)
      allow read: if isAuthenticated();
      
      // Users can create their own document (during signup)
      allow create: if isUser(uid) && 
                   request.resource.data.keys().hasAll(['email', 'displayName', 'role', 'createdAt']) &&
                   request.resource.data.role in [0, 1] &&
                   request.resource.data.size() <= 20;

      // Users can update their own document
      allow update: if isUser(uid) && 
                   !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'uid', 'role']) &&
                   request.resource.data.size() <= 20;

      // No deletes allowed
      allow delete: if false;
    }

    // ========== CLASSES COLLECTION ==========
    match /classes/{classId} {
      // Any authenticated user can read a class (for discovery)
      allow read: if isAuthenticated() && 
                     (isClassMember(classId) || isClassTeacher(classId));
      
      // Only teachers can create classes
      allow create: if isAuthenticated() && 
                       request.resource.data.teacherUid == request.auth.uid &&
                       request.resource.data.keys().hasAll(['name', 'teacherUid', 'memberUids', 'createdAt']) &&
                       request.resource.data.memberUids is list &&
                       request.resource.data.memberUids.size() >= 0;
      
      // Only class teacher can update
      allow update: if isClassTeacher(classId) && 
                       resource.data.teacherUid == request.resource.data.teacherUid;
      
      // Only class teacher can delete
      allow delete: if isClassTeacher(classId);
    }

    // ========== QUIZZES COLLECTION ==========
    match /quizzes/{quizId} {
      // Allow read access for any of the following:
      // - The quiz creator (authenticated)
      // - Quizzes that are published
      // - Anyone who has a valid non-empty `quizCode`
      // NOTE: security checks for a quiz password should be performed by the
      // client via a query (e.g., where('quizCode', code).where('password', pw)),
      // since request.resource is not available for reads.
      allow read: if (
        // Creator may always read their own quiz
        (isAuthenticated() && resource.data.createdBy == request.auth.uid) ||
        // Published quizzes are publicly readable
        (resource.data.keys().hasAny(['published']) && resource.data.published == true) ||
        // Anyone with the quiz code can read
        (resource.data.keys().hasAny(['quizCode']) && resource.data.quizCode != null && resource.data.quizCode != "")
      );

      // Allow quiz creators to create quizzes
      allow create: if isAuthenticated() &&
                   request.resource.data.createdBy == request.auth.uid &&
                   request.resource.data.keys().hasAll(['title', 'description', 'timeLimitSeconds', 'createdBy', 'createdAt']) &&
                   request.resource.data.timeLimitSeconds > 0 &&
                   request.resource.data.published == false;

      // Allow quiz creators to update their quizzes
      // Also allow anyone to increment `totalAttempts` only (client-side increments)
      allow update: if (
        (isAuthenticated() && resource.data.createdBy == request.auth.uid && resource.data.createdBy == request.resource.data.createdBy) ||
        (
          // Only totalAttempts field changed and it's non-decreasing
          request.resource.data.keys().hasAll(['totalAttempts']) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['totalAttempts']) &&
          (resource.data.totalAttempts == null || request.resource.data.totalAttempts >= resource.data.totalAttempts)
        )
      );

      // Allow quiz creators to delete their quizzes
      allow delete: if isAuthenticated() && resource.data.createdBy == request.auth.uid;
    }

    // ========== QUESTIONS SUBCOLLECTION ==========
    match /quizzes/{quizId}/questions/{questionId} {
      // Allow read access if the parent quiz is accessible.
      // Users with a valid `quizCode` should be able to read questions even
      // if they are unauthenticated (so anyone with the code can take the quiz).
      allow read: if (
        // Creator always has access
        isQuizCreator(quizId) ||
        // Access via quiz code (no authentication required)
        (
          getQuiz(quizId).keys().hasAny(['quizCode']) &&
          getQuiz(quizId).quizCode != null &&
          getQuiz(quizId).quizCode != ""
        ) ||
        // Published quizzes are publicly readable
        (getQuiz(quizId).published == true)
      );
      
      // Create: Only quiz creator can add questions
      allow create: if isQuizCreator(quizId) && 
                       request.resource.data.keys().hasAll(['type', 'prompt', 'choices', 'correctAnswers', 'points', 'order', 'createdAt']) &&
                       request.resource.data.choices is list &&
                       request.resource.data.points >= 0;
      
      // Update: Only quiz creator can edit
      allow update: if isQuizCreator(quizId);
      
      // Delete: Only quiz creator can delete
      allow delete: if isQuizCreator(quizId);
    }

    // ========== ATTEMPTS COLLECTION ==========
    match /attempts/{attemptId} {
      // Read: owner or quiz creator can read; additionally allow read if the
      // associated quiz is accessible via a quizCode (so code-holders can view)
      allow read: if (
        (isAuthenticated() && (isUser(resource.data.userId) || isQuizCreator(resource.data.quizId))) ||
        (
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.keys().hasAny(['quizCode']) &&
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.quizCode != null &&
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.quizCode != ""
        )
      );

      // TEMP DEBUG: allow any client to create attempts. Remove this after debugging.
      allow create: if true;

      // Update: allow authenticated owner to update their attempt, OR allow
      // updates for attempts tied to a quiz with a quizCode (so code-holders
      // can submit/patch attempts). Updates must preserve userId and quizId.
      allow update: if (
        (isAuthenticated() && request.auth.uid == resource.data.userId &&
           request.resource.data.userId == resource.data.userId &&
           request.resource.data.quizId == resource.data.quizId)
        ||
        (
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.keys().hasAny(['quizCode']) &&
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.quizCode != null &&
          get(/databases/$(database)/documents/quizzes/$(resource.data.quizId)).data.quizCode != "" &&
          request.resource.data.userId == resource.data.userId &&
          request.resource.data.quizId == resource.data.quizId
        )
      );

      // Allow delete if quiz creator (for cleanup) or the attempt owner.
      // This lets users remove their own attempts from their history.
      allow delete: if isQuizCreator(resource.data.quizId) || isAuthenticated() && request.auth.uid == resource.data.userId;
    }

    // ========== VIOLATIONS COLLECTION ==========
    match /violations/{violationId} {
      // Teachers can read violations for their quizzes, and attempt owners
      // can read violations tied to their own attempts. This allows users
      // to fetch and delete their own violations when removing attempt history.
      allow read: if isAuthenticated() && (
                     isQuizCreator(get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.quizId) ||
                     get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.userId == request.auth.uid
                   );
      
      // Service account or backend only (restrict in production)
      // For now, allow attempts service to log violations
      allow create: if isAuthenticated() && 
                       request.resource.data.keys().hasAll(['attemptId', 'userId', 'type', 'detectedAt']) &&
                       request.resource.data.type >= 0 &&
                       request.resource.data.type <= 8; // Extended enum range
      
      // No updates (immutable audit trail)
      allow update: if false;

      // Allow delete if related to a quiz owned by the user or the attempt owner.
      // This permits teachers to remove violations for their quizzes and users
      // to remove violations tied to their own attempts when deleting history.
      allow delete: if isAuthenticated() && (
                       isQuizCreator(get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.quizId) ||
                       get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.userId == request.auth.uid
                     );
    }

    // ========== DEFAULT DENY ==========
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
