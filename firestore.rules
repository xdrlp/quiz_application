// Firestore Security Rules for Quiz Application
// Deploy to Firebase Console: Firestore > Rules

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUser(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    function getUser(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }
    
    // Safe check for class access
    function hasClassAccess(quizClassIds) {
       // Check if user doc exists
       return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
              // Check if 'classes' field exists
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.keys().hasAny(['classes']) &&
              // Check intersection
              quizClassIds.hasAny(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.classes);
    }
    
    function getQuiz(quizId) {
      return get(/databases/$(database)/documents/quizzes/$(quizId)).data;
    }
    
    function isQuizCreator(quizId) {
      return isAuthenticated() && getQuiz(quizId).createdBy == request.auth.uid;
    }
    
    function isClassMember(classId) {
      return isAuthenticated() && 
             classId in getUser(request.auth.uid).classes;
    }
    
    function isClassTeacher(classId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/classes/$(classId)).data.teacherUid == request.auth.uid;
    }

    // ========== USERS COLLECTION ==========
    match /users/{uid} {
      // Users can read their own document
      allow read: if isUser(uid);
      
      // Users can create their own document (during signup)
      allow create: if isUser(uid) && 
                       request.resource.data.keys().hasAll(['email', 'displayName', 'role', 'createdAt']) &&
                       request.resource.data.role in [0, 1] &&
                       request.resource.data.size() <= 20; // Increased limit to allow optional fields
      
      // Users can update their own document
      allow update: if isUser(uid) && 
                       // Prevent changing email, role, uid
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'uid', 'role']) &&
                       request.resource.data.size() <= 20;
      
      // No deletes allowed
      allow delete: if false;
    }

    // ========== CLASSES COLLECTION ==========
    match /classes/{classId} {
      // Any authenticated user can read a class (for discovery)
      allow read: if isAuthenticated() && 
                     (isClassMember(classId) || isClassTeacher(classId));
      
      // Only teachers can create classes
      allow create: if isAuthenticated() && 
                       request.resource.data.teacherUid == request.auth.uid &&
                       request.resource.data.keys().hasAll(['name', 'teacherUid', 'memberUids', 'createdAt']) &&
                       request.resource.data.memberUids is list &&
                       request.resource.data.memberUids.size() >= 0;
      
      // Only class teacher can update
      allow update: if isClassTeacher(classId) && 
                       resource.data.teacherUid == request.resource.data.teacherUid;
      
      // Only class teacher can delete
      allow delete: if isClassTeacher(classId);
    }

    // ========== QUIZZES COLLECTION ==========
    match /quizzes/{quizId} {
      // Read: Public quizzes, quizzes in user's classes, or creator's quizzes
      allow read: if isAuthenticated() && (
        resource.data.createdBy == request.auth.uid ||
        (
          // Ensure published matches first
          resource.data.keys().hasAny(['published']) &&
          resource.data.published == true && 
          (
            // 1. Access by Class (Public or Member) - requires classIds
            (
              resource.data.keys().hasAny(['classIds']) && 
              (resource.data.classIds.size() == 0 || hasClassAccess(resource.data.classIds))
            ) ||
            // 2. Access by Quiz Code - doesn't require classIds
            (
              resource.data.keys().hasAny(['quizCode']) && 
              resource.data.quizCode != null && 
              resource.data.quizCode != ""
            )
          )
        )
      );
      
      // Create: Any authenticated user can create
      allow create: if isAuthenticated() && 
                       request.resource.data.createdBy == request.auth.uid &&
                       request.resource.data.keys().hasAll(['title', 'description', 'timeLimitSeconds', 'createdBy', 'createdAt']) &&
                       request.resource.data.timeLimitSeconds > 0 &&
                       request.resource.data.published == false;
      
      // Update: Only creator can update
      allow update: if isAuthenticated() && resource.data.createdBy == request.auth.uid && 
                       resource.data.createdBy == request.resource.data.createdBy; // Prevent changing creator
      
      // Delete: Only creator can delete (and only if no attempts exist)
      allow delete: if isAuthenticated() && resource.data.createdBy == request.auth.uid;
    }

    // ========== QUESTIONS SUBCOLLECTION ==========
    match /quizzes/{quizId}/questions/{questionId} {
      // Read: Same access as parent quiz
      allow read: if isAuthenticated() && 
                     (isQuizCreator(quizId) ||
                      (getQuiz(quizId).published && 
                       getQuiz(quizId).classIds.size() == 0) ||
                      (getQuiz(quizId).published && 
                       hasClassAccess(getQuiz(quizId).classIds)));
      
      // Create: Only quiz creator can add questions
      allow create: if isQuizCreator(quizId) && 
                       request.resource.data.keys().hasAll(['type', 'prompt', 'choices', 'correctAnswers', 'points', 'order', 'createdAt']) &&
                       request.resource.data.choices is list &&
                       request.resource.data.points >= 0;
      
      // Update: Only quiz creator can edit
      allow update: if isQuizCreator(quizId);
      
      // Delete: Only quiz creator can delete
      allow delete: if isQuizCreator(quizId);
    }

    // ========== ATTEMPTS COLLECTION ==========
    match /attempts/{attemptId} {
      // Student can read their own attempts; teacher can read attempts for their quizzes
      allow read: if isAuthenticated() && 
                     (isUser(resource.data.userId) ||
                      isQuizCreator(resource.data.quizId));
      
      // Student can create their own attempt
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['quizId', 'userId', 'startedAt', 'score', 'totalPoints', 'answers']) &&
                       request.resource.data.score >= 0;
      
      // Student can only update their own attempt (to submit)
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.quizId == resource.data.quizId;
      
      // Allow delete if quiz creator (for cleanup)
      allow delete: if isQuizCreator(resource.data.quizId);
    }

    // ========== VIOLATIONS COLLECTION ==========
    match /violations/{violationId} {
      // Teachers can read violations for their quizzes (by checking the attempt's quizId)
      allow read: if isAuthenticated() && 
                     isQuizCreator(get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.quizId);
      
      // Service account or backend only (restrict in production)
      // For now, allow attempts service to log violations
      allow create: if isAuthenticated() && 
                       request.resource.data.keys().hasAll(['attemptId', 'userId', 'type', 'detectedAt']) &&
                       request.resource.data.type >= 0 &&
                       request.resource.data.type <= 8; // Extended enum range
      
      // No updates (immutable audit trail)
      allow update: if false;

      // Allow delete if related to a quiz owned by the user
      allow delete: if isAuthenticated() && 
                       isQuizCreator(get(/databases/$(database)/documents/attempts/$(resource.data.attemptId)).data.quizId);
    }

    // ========== QUIZ BACKUPS COLLECTION ==========
    match /quiz_backups/{backupId} {
      // Allow create if backup belongs to a quiz created by the user
      allow create: if isAuthenticated() && 
                       request.resource.data.quiz.createdBy == request.auth.uid;

      // Allow read/delete if user owns the backup
      allow read, delete: if isAuthenticated() && 
                             resource.data.quiz.createdBy == request.auth.uid;
    }

    // ========== DEFAULT DENY ==========
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
